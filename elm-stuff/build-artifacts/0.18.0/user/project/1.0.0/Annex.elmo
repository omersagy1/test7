var _user$project$Annex$doubleFold = F4(
	function (mutateFn, argList, struct1, struct2) {
		doubleFold:
		while (true) {
			var _p0 = argList;
			if (_p0.ctor === '[]') {
				return {ctor: '_Tuple2', _0: struct1, _1: struct2};
			} else {
				var _p1 = A3(mutateFn, _p0._0, struct1, struct2);
				var s1 = _p1._0;
				var s2 = _p1._1;
				var _v1 = mutateFn,
					_v2 = _p0._1,
					_v3 = s1,
					_v4 = s2;
				mutateFn = _v1;
				argList = _v2;
				struct1 = _v3;
				struct2 = _v4;
				continue doubleFold;
			}
		}
	});
var _user$project$Annex$foldingMutate = F3(
	function (mutateFn, argList, struct) {
		var _p2 = argList;
		if (_p2.ctor === '[]') {
			return {
				ctor: '_Tuple2',
				_0: {ctor: '[]'},
				_1: struct
			};
		} else {
			var _p3 = A2(mutateFn, _p2._0, struct);
			var result = _p3._0;
			var nextStruct = _p3._1;
			var _p4 = A3(_user$project$Annex$foldingMutate, mutateFn, _p2._1, nextStruct);
			var restResults = _p4._0;
			var finalStruct = _p4._1;
			return {
				ctor: '_Tuple2',
				_0: {ctor: '::', _0: result, _1: restResults},
				_1: finalStruct
			};
		}
	});
var _user$project$Annex_ops = _user$project$Annex_ops || {};
_user$project$Annex_ops['!!'] = F2(
	function (l, i) {
		return _elm_lang$core$List$head(
			A2(
				_elm_lang$core$List$drop,
				i,
				A2(_elm_lang$core$List$take, i + 1, l)));
	});
var _user$project$Annex$maybePerform = F3(
	function (mutateFn, maybeArg, struct) {
		var _p5 = maybeArg;
		if (_p5.ctor === 'Nothing') {
			return struct;
		} else {
			return A2(mutateFn, _p5._0, struct);
		}
	});
var _user$project$Annex$maybePred = F2(
	function (pred, m) {
		var _p6 = m;
		if (_p6.ctor === 'Nothing') {
			return false;
		} else {
			return pred(_p6._0);
		}
	});
var _user$project$Annex$maybeToList = function (m) {
	var _p7 = m;
	if (_p7.ctor === 'Nothing') {
		return {ctor: '[]'};
	} else {
		return {
			ctor: '::',
			_0: _p7._0,
			_1: {ctor: '[]'}
		};
	}
};
var _user$project$Annex$concatMaybes = function (l) {
	return _elm_lang$core$List$concat(
		A2(_elm_lang$core$List$map, _user$project$Annex$maybeToList, l));
};
var _user$project$Annex$isJust = function (m) {
	var _p8 = m;
	if (_p8.ctor === 'Nothing') {
		return false;
	} else {
		return true;
	}
};
var _user$project$Annex$ignoreResult = F2(
	function (f, x) {
		return _elm_lang$core$Tuple$second(
			f(x));
	});
var _user$project$Annex$maybeChain = F2(
	function (callback, maybe) {
		var _p9 = maybe;
		if (_p9.ctor === 'Nothing') {
			return _elm_lang$core$Maybe$Nothing;
		} else {
			return _elm_lang$core$Maybe$Just(
				callback(_p9._0));
		}
	});
var _user$project$Annex$rangeToZero = F2(
	function (initial, len) {
		var step = initial / (_elm_lang$core$Basics$toFloat(len) - 1);
		return A2(
			_elm_lang$core$List$map,
			function (x) {
				return initial - (step * _elm_lang$core$Basics$toFloat(x));
			},
			A2(_elm_lang$core$List$range, 0, len - 1));
	});
var _user$project$Annex$zip = _elm_lang$core$List$map2(
	F2(
		function (v0, v1) {
			return {ctor: '_Tuple2', _0: v0, _1: v1};
		}));
var _user$project$Annex$enumerate = function (list) {
	return A2(
		_user$project$Annex$zip,
		A2(
			_elm_lang$core$List$range,
			0,
			_elm_lang$core$List$length(list)),
		list);
};
