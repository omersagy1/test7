var _user$project$Annex$maybeMutate = F3(
	function (mutateFn, maybeArg, struct) {
		var _p0 = maybeArg;
		if (_p0.ctor === 'Nothing') {
			return struct;
		} else {
			return A2(mutateFn, _p0._0, struct);
		}
	});
var _user$project$Annex$maybePred = F2(
	function (pred, m) {
		var _p1 = m;
		if (_p1.ctor === 'Nothing') {
			return false;
		} else {
			return pred(_p1._0);
		}
	});
var _user$project$Annex$maybeToList = function (m) {
	var _p2 = m;
	if (_p2.ctor === 'Nothing') {
		return {ctor: '[]'};
	} else {
		return {
			ctor: '::',
			_0: _p2._0,
			_1: {ctor: '[]'}
		};
	}
};
var _user$project$Annex$concatMaybes = function (l) {
	return _elm_lang$core$List$concat(
		A2(_elm_lang$core$List$map, _user$project$Annex$maybeToList, l));
};
var _user$project$Annex$isJust = function (m) {
	var _p3 = m;
	if (_p3.ctor === 'Nothing') {
		return false;
	} else {
		return true;
	}
};
var _user$project$Annex$ignoreResult = F2(
	function (f, x) {
		return _elm_lang$core$Tuple$second(
			f(x));
	});
var _user$project$Annex$maybeChain = F2(
	function (callback, maybe) {
		var _p4 = maybe;
		if (_p4.ctor === 'Nothing') {
			return _elm_lang$core$Maybe$Nothing;
		} else {
			return _elm_lang$core$Maybe$Just(
				callback(_p4._0));
		}
	});
var _user$project$Annex$rangeToZero = F2(
	function (initial, len) {
		var step = initial / (_elm_lang$core$Basics$toFloat(len) - 1);
		return A2(
			_elm_lang$core$List$map,
			function (x) {
				return initial - (step * _elm_lang$core$Basics$toFloat(x));
			},
			A2(_elm_lang$core$List$range, 0, len - 1));
	});
var _user$project$Annex$zip = _elm_lang$core$List$map2(
	F2(
		function (v0, v1) {
			return {ctor: '_Tuple2', _0: v0, _1: v1};
		}));
var _user$project$Annex$enumerate = function (list) {
	return A2(
		_user$project$Annex$zip,
		A2(
			_elm_lang$core$List$range,
			0,
			_elm_lang$core$List$length(list)),
		list);
};
